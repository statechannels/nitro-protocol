---
id: redistribution-of-assets
title: Redistribution of Assets
sidebar_label: Redistribution of Assets
---

In order for state channels to hold value for their participants, they must lock up some assets into the adjudicator, which are released conditional on their subsequent behaviour. Operations must exist that allow a finalized outcome to be **redistributed** and ultimately for assets to be withdrawn by participants. Again, this property may be relied on counterfactually: the fact that the distribution is possible implies value is held in the channel, even if the redistribution is not actually performed.

Redistribution is managed by the following on-chain operations:

**Deposit**  
This function is called with an address argument, and accompanied by assets `msg.value`:

In `force-move-games/packages/fmg-nitro-adjudicator/contracts/NitroAdjudicator.sol`:

```javascript
    function deposit(address destination) public payable {
            holdings[destination] = holdings[destination].add(msg.value);
            emit Deposited(destination,msg.value, holdings[destination]);
            }
```

The address can be:

- A **participant address,** generated by ECDSA and having a private key counterpart; or
- A **channel address,** generated by hashing the channel participants with a nonce \(defined in the [state format](commitment-format.md)\).

The result of this transaction is that destination â€˜s entry in the adjudicatorâ€™s allocations mapping is increased by `msg.value`.

#### ðŸ”’ðŸ”’Conclude

This function registers a `ConclusionProof` \(aka `FinalizationProof`\).

In `force-move-games/packages/fmg-nitro-adjudicator/contracts/NitroAdjudicator.sol`:

```javascript
function _conclude(ConclusionProof memory proof) internal {...}
```

As long as the channel is not already finalized, the outcome is regsitered against the channel address in a mapping stored on chain.

ðŸ”’**Withdraw**  
This function is called with a participant, a destination, an amount and a signature:

```javascript
function withdraw(
 address participant,
 address payable destination,
 uint amount,
 uint8 _v,
 bytes32 _r,
 bytes32 _s
) public payable { ... }
```

If the signature \(`v`, `r` and `s` arguments\) of the other arguments corresponds to the participant address, and if this address has sufficient funds to cover amount, the result is that the contract pays amount to destination \(which can be any blockchain address\).

**Transfer**  
This function is called with a channel, a destination and an amount:

In `force-move-games/packages/fmg-nitro-adjudicator/contracts/NitroAdjudicator.sol`:

```javascript
function transfer(address channel, address destination, uint amount) public { ... }
```

If the `channe`l can **afford** `amount` **for** `destination`, the result is that `destination`'s entry in the adjudicatorâ€™s allocations mapping is incremented by `amount`, and the `channel`'s entry is decremented. The outcome of the `channel` is also amended, so that the amount allocated to destination is reduced by `amount`. The specification for a channel affording an amount for a destination is given in the section on [value calculations](value-calculations.md).

**Claim**  
This function is called with a guarantor, a recipient and an amount:

In `force-move-games/packages/fmg-nitro-adjudicator/contracts/NitroAdjudicator.sol`:

```javascript
function claim(address guarantor, address recipient, uint amount) public { ... }
```

If `guarantor`guarantees `channel`, and can afford `amount` for `recipient`, the result is that `guarantor` has its entry in the adjudicatorâ€™s allocations mapping reduced by `amount`, and `recipient` has their entry correspondingly increased. The outcome of `channel` is also amended, so that the amount allocated to destination is reduced by `amount`.
